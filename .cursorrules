# MindfulSpace - AI Journaling Companion
## Cursor AI Rules for Privacy-First Journaling Platform

You are an expert in TypeScript, Next.js 14 App Router, React, Prisma, PostgreSQL, Supabase, Anthropic Claude API, shadcn/ui, Radix UI, Tailwind CSS, and privacy-first AI application development.

---

## Project Context

You are building **MindfulSpace**, an AI-powered journaling companion for a Palo Alto Networks hackathon case study. This is a privacy-first progressive web application that helps users maintain consistent journaling habits through intelligent AI assistance.

**Key Requirements:**
- 48-hour development timeline (deadline: Feb 1, 2026 5:00 PM PST)
- Must demonstrate strong AI integration (using Anthropic Claude API)
- Must prioritize user privacy and security (critical for PANW judges)
- Must showcase professional code quality and best practices
- Must create impressive demo with real-time features

**Success Metrics (Judge Scoring):**
1. User Engagement - How effectively does the app encourage journaling?
2. Insightfulness - Do AI insights help discover meaningful patterns?
3. Privacy & Trust - Is the design secure, private, and non-judgmental?
4. AI Application - How well does it leverage NLP and sentiment analysis?
5. Code Quality - Structure, correctness, error handling, best practices

---

## Tech Stack

**Core Framework:**
- Next.js 14 (App Router) - Full-stack framework
- TypeScript 5.x - Type safety throughout
- React 18 - UI components

**Database & Auth:**
- Supabase (PostgreSQL) - Database and authentication
- Prisma 5.x - Type-safe ORM

**UI & Styling:**
- Tailwind CSS 3.x - Utility-first styling
- shadcn/ui - Pre-built accessible components (Radix UI)
- Lucide React - Icons
- Recharts - Data visualization

**AI & Privacy:**
- Anthropic Claude Sonnet 4 API - Generative AI tasks (prompts, suggestions, summaries)
- `sentiment` npm package (AFINN-165) - Local sentiment analysis
- `compromise` - Local theme extraction
- Custom PII masking - Privacy protection before API calls

**Data Fetching:**
- SWR - Client-side data fetching with cache

**Deployment:**
- Vercel - Hosting and deployment

---

## Code Style and Structure

### General Principles
- Write concise, technical TypeScript code with accurate examples
- Use functional and declarative programming patterns; avoid classes
- Prefer iteration and modularization over code duplication
- Use descriptive variable names with auxiliary verbs (e.g., isLoading, hasError, canSubmit)
- Structure files: exported component, subcomponents, helpers, static content, types
- Follow mobile-first responsive design approach

### TypeScript Usage
- Use TypeScript for ALL code; no JavaScript files
- Prefer interfaces over types for object shapes
- Avoid enums; use const objects or maps instead
- Use functional components with TypeScript interfaces
- Always define explicit return types for functions
- Use proper type narrowing and guards

### Naming Conventions
- Use lowercase with dashes for directories (e.g., `components/journal-editor`)
- Use PascalCase for component files (e.g., `EntryEditor.tsx`)
- Favor named exports over default exports for components
- Use descriptive names: `isAnalyzing`, `hasEntries`, `sentimentScore`

### File Structure
```typescript
// 1. Imports
import { ComponentType } from 'react';
import { helperFunction } from '@/lib/utils';

// 2. Types/Interfaces
interface ComponentProps {
  // ...
}

// 3. Component
export function Component({ prop }: ComponentProps): JSX.Element {
  // 4. Hooks
  // 5. Handlers
  // 6. Render
}

// 7. Helper functions (if any)
// 8. Constants (if any)
```

---

## Next.js 14 App Router Conventions

### Routing Structure
- Use App Router exclusively (no pages/ directory)
- Group routes with parentheses: `(auth)/`, `(dashboard)/`
- Use `page.tsx` for route components
- Use `layout.tsx` for shared layouts
- Use `loading.tsx` for loading states
- Use `error.tsx` for error boundaries

### Server vs Client Components
- **Default to Server Components** - Use RSC whenever possible
- **Use 'use client' sparingly** - Only when you need:
  - Browser APIs (localStorage, window)
  - Event handlers (onClick, onChange)
  - React hooks (useState, useEffect)
  - Real-time interactivity
- **Pattern:** Create small client component wrappers around interactive elements
- **Avoid:** Using 'use client' for data fetching or state management

### Data Fetching
- Use async Server Components for data fetching
- Use Server Actions for mutations
- Use SWR for client-side data with caching
- Implement proper loading and error states
- Use Suspense boundaries for streaming

### API Routes
- Place all API routes in `app/api/`
- Use route handlers: `route.ts`
- Return `Response` or `NextResponse` objects
- Implement proper error handling with try-catch
- Use Zod for request validation
- Return JSON with appropriate status codes

---

## React & Component Patterns

### Component Structure
```typescript
'use client'; // Only if needed

import { useState } from 'react';
import { Button } from '@/components/ui/button';

interface ComponentProps {
  title: string;
  onSave: (data: string) => void;
}

export function Component({ title, onSave }: ComponentProps): JSX.Element {
  const [data, setData] = useState<string>('');
  
  const handleSubmit = async () => {
    try {
      await onSave(data);
    } catch (error) {
      console.error('Save failed:', error);
    }
  };
  
  return (
    <div className="space-y-4">
      <h2 className="text-2xl font-bold">{title}</h2>
      <Button onClick={handleSubmit}>Save</Button>
    </div>
  );
}
```

### Hooks Best Practices
- Keep hooks at the top of component
- Use custom hooks for reusable logic
- Name custom hooks with `use` prefix
- Declare dependencies explicitly
- Use `useCallback` for event handlers passed to children
- Use `useMemo` for expensive calculations only

### Error Handling
- Use error boundaries for component errors
- Implement try-catch in async operations
- Provide user-friendly error messages
- Log errors appropriately (not console.log in production)
- Use guard clauses for early returns

---

## Database & Prisma

### Schema Conventions
- Use descriptive model names (PascalCase)
- Use camelCase for field names
- Add `@@map()` for snake_case table names
- Include `createdAt` and `updatedAt` timestamps
- Use proper relations and indexes
- Add comments for complex fields

### Query Patterns
```typescript
// Good: Type-safe with explicit select
const entries = await prisma.entry.findMany({
  where: { userId },
  select: {
    id: true,
    content: true,
    sentimentScore: true,
    createdAt: true,
  },
  orderBy: { createdAt: 'desc' },
});

// Good: Include relations when needed
const entry = await prisma.entry.findUnique({
  where: { id },
  include: {
    analysis: true,
    suggestions: true,
  },
});
```

### Error Handling
```typescript
try {
  const entry = await prisma.entry.create({ data });
} catch (error) {
  if (error instanceof Prisma.PrismaClientKnownRequestError) {
    // Handle specific errors
  }
  throw error;
}
```

---

## AI Integration Guidelines

### Anthropic Claude API Usage

**CRITICAL:** This is a Palo Alto Networks case study. Using Claude API demonstrates you know their product ecosystem.

#### When to Use Claude API:
1. **Dynamic Prompt Generation** - Context-aware journal prompts
2. **Real-Time Writing Companion** - Follow-up questions as user types
3. **Weekly Summaries** - Narrative synthesis of entries
4. **Advanced Theme Analysis** - Deep contextual understanding

#### When to Use Local AFINN:
1. **Real-Time Sentiment Display** - Instant feedback as user types
2. **Basic Sentiment Scoring** - Store with each entry
3. **Sentiment Trends** - Aggregate for visualizations
4. **Basic Keyword Tagging** - Simple theme identification

### PII Masking (CRITICAL for Privacy)

**ALWAYS mask PII before sending to Claude API:**

```typescript
function maskPII(text: string): string {
  let masked = text;
  
  // Email addresses
  masked = masked.replace(/[\w.-]+@[\w.-]+\.\w+/g, '[EMAIL]');
  
  // Phone numbers
  masked = masked.replace(/(\+\d{1,3}[-.]?)?\(?\d{3}\)?[-.]?\d{3}[-.]?\d{4}/g, '[PHONE]');
  
  // SSN
  masked = masked.replace(/\d{3}-\d{2}-\d{4}/g, '[SSN]');
  
  // Credit cards
  masked = masked.replace(/\d{4}[-\s]?\d{4}[-\s]?\d{4}[-\s]?\d{4}/g, '[CARD]');
  
  // Addresses
  masked = masked.replace(/\d+\s+[\w\s]+(?:street|st|avenue|ave|road|rd|lane|ln|drive|dr)/gi, '[ADDRESS]');
  
  return masked;
}
```

### Claude API Best Practices

```typescript
// app/api/ai/suggest/route.ts
import Anthropic from '@anthropic-ai/sdk';
import { maskPII } from '@/lib/pii-masking';

const anthropic = new Anthropic({
  apiKey: process.env.ANTHROPIC_API_KEY,
});

export async function POST(req: Request): Promise<Response> {
  try {
    const { text } = await req.json();
    
    // ALWAYS mask PII first
    const maskedText = maskPII(text);
    
    const message = await anthropic.messages.create({
      model: 'claude-sonnet-4-20250514',
      max_tokens: 200,
      messages: [{
        role: 'user',
        content: `You are an empathetic journaling coach. The user wrote: "${maskedText}". 
                  Generate ONE gentle follow-up question (max 15 words) to encourage deeper reflection.`
      }]
    });
    
    const suggestion = message.content[0].text;
    
    return Response.json({ suggestion });
  } catch (error) {
    console.error('Claude API error:', error);
    return Response.json(
      { error: 'Failed to generate suggestion' },
      { status: 500 }
    );
  }
}
```

### Local Sentiment Analysis

```typescript
// lib/sentiment.ts
import Sentiment from 'sentiment';

const sentiment = new Sentiment();

export function analyzeSentiment(text: string) {
  const result = sentiment.analyze(text);
  
  return {
    score: result.comparative, // -5 to +5
    label: getSentimentLabel(result.comparative),
    positiveWords: result.positive,
    negativeWords: result.negative,
  };
}

function getSentimentLabel(score: number): string {
  if (score > 0.5) return 'positive';
  if (score < -0.5) return 'negative';
  return 'neutral';
}
```

### Caching Strategy

```typescript
// Cache AI responses to reduce API calls
const CACHE_DURATION = 3600; // 1 hour

async function getCachedOrGenerate(key: string, generator: () => Promise<string>) {
  const cached = await getCached(key);
  if (cached) return cached;
  
  const result = await generator();
  await cache(key, result, CACHE_DURATION);
  return result;
}
```

---

## UI/UX Patterns with shadcn/ui

### Component Usage
- Import shadcn/ui components from `@/components/ui`
- Customize via Tailwind classes, not CSS files
- Use composition over configuration
- Implement proper loading states
- Handle error states gracefully

### Common Patterns

```typescript
// Form with validation
import { Button } from '@/components/ui/button';
import { Textarea } from '@/components/ui/textarea';
import { toast } from '@/components/ui/use-toast';

export function EntryForm() {
  const [content, setContent] = useState('');
  const [isSubmitting, setIsSubmitting] = useState(false);
  
  const handleSubmit = async () => {
    setIsSubmitting(true);
    try {
      await saveEntry(content);
      toast({ title: 'Entry saved successfully' });
      setContent('');
    } catch (error) {
      toast({ 
        title: 'Failed to save entry',
        variant: 'destructive' 
      });
    } finally {
      setIsSubmitting(false);
    }
  };
  
  return (
    <div className="space-y-4">
      <Textarea
        value={content}
        onChange={(e) => setContent(e.target.value)}
        placeholder="Start writing..."
        className="min-h-[200px]"
      />
      <Button 
        onClick={handleSubmit}
        disabled={isSubmitting || !content.trim()}
      >
        {isSubmitting ? 'Saving...' : 'Save Entry'}
      </Button>
    </div>
  );
}
```

### Styling Guidelines
- Use Tailwind utility classes
- Follow mobile-first approach (`sm:`, `md:`, `lg:`)
- Use consistent spacing scale (p-4, gap-6, space-y-4)
- Implement dark mode support (optional but impressive)
- Use semantic color classes (bg-primary, text-destructive)

---

## Performance Optimization

### Next.js Specific
- Minimize `'use client'` usage
- Use Server Components for data fetching
- Implement proper Suspense boundaries
- Use `loading.tsx` for route-level loading states
- Optimize images with `next/image`
- Use dynamic imports for large components

### React Patterns
- Memoize expensive calculations with `useMemo`
- Memoize callbacks with `useCallback`
- Use `React.memo` for pure components
- Implement virtualization for long lists (if needed)
- Debounce expensive operations (AI calls)

### Database Queries
- Use select to limit fields returned
- Add indexes for frequently queried fields
- Implement pagination for large datasets
- Use connection pooling
- Cache frequently accessed data

---

## Security & Privacy (CRITICAL FOR PANW)

### Authentication
- Use Supabase Auth for authentication
- Protect API routes with middleware
- Verify user sessions on every request
- Implement proper session management
- Use HTTPS everywhere (Vercel default)

### Data Privacy
- **NEVER** send unmasked PII to external APIs
- Store sensitive data encrypted
- Implement Row Level Security (RLS) in Supabase
- Allow users to export their data
- Provide clear data deletion options
- Display privacy indicators when AI is used

### Environment Variables
- Store secrets in `.env.local` (never commit)
- Use `NEXT_PUBLIC_` prefix only for client-safe vars
- Validate env vars on startup
- Use different keys for dev/production

```typescript
// lib/env.ts
import { z } from 'zod';

const envSchema = z.object({
  DATABASE_URL: z.string().url(),
  ANTHROPIC_API_KEY: z.string().startsWith('sk-ant-'),
  NEXT_PUBLIC_SUPABASE_URL: z.string().url(),
});

export const env = envSchema.parse(process.env);
```

---

## Testing Strategy

### What to Test
- API routes (error cases, validation)
- Helper functions (PII masking, sentiment analysis)
- Component rendering (critical paths)
- Form submissions and validation
- Error boundaries

### Testing Pattern
```typescript
// __tests__/lib/pii-masking.test.ts
import { maskPII } from '@/lib/pii-masking';

describe('maskPII', () => {
  it('should mask email addresses', () => {
    const text = 'Contact me at john@example.com';
    expect(maskPII(text)).toBe('Contact me at [EMAIL]');
  });
  
  it('should mask phone numbers', () => {
    const text = 'Call me at 555-123-4567';
    expect(maskPII(text)).toBe('Call me at [PHONE]');
  });
});
```

---

## Git Workflow

### Commit Messages
```
feat: add real-time sentiment indicator
fix: resolve PII masking edge case
refactor: extract AI prompt logic to helper
docs: update API route documentation
test: add tests for sentiment analysis
```

### Branch Strategy
- `main` - production-ready code
- Feature branches for major features
- Commit frequently with clear messages

---

## Error Handling Patterns

### API Routes
```typescript
export async function POST(req: Request): Promise<Response> {
  try {
    // Validate input
    const body = await req.json();
    const validated = schema.parse(body);
    
    // Business logic
    const result = await processData(validated);
    
    return Response.json(result);
  } catch (error) {
    if (error instanceof z.ZodError) {
      return Response.json(
        { error: 'Invalid input', details: error.errors },
        { status: 400 }
      );
    }
    
    console.error('Unexpected error:', error);
    return Response.json(
      { error: 'Internal server error' },
      { status: 500 }
    );
  }
}
```

### Client Components
```typescript
export function Component() {
  const [error, setError] = useState<string | null>(null);
  
  const handleAction = async () => {
    try {
      setError(null);
      await riskyOperation();
    } catch (error) {
      setError(error instanceof Error ? error.message : 'An error occurred');
    }
  };
  
  return (
    <div>
      {error && <ErrorAlert message={error} />}
      {/* rest of component */}
    </div>
  );
}
```

---

## Documentation Standards

### Component Documentation
```typescript
/**
 * EntryEditor - Main journal entry writing interface
 * 
 * Features:
 * - Real-time sentiment analysis (AFINN)
 * - AI-powered writing suggestions (Claude API)
 * - Auto-save functionality
 * - PII masking before AI calls
 * 
 * @example
 * ```tsx
 * <EntryEditor 
 *   initialContent=""
 *   onSave={handleSave}
 * />
 * ```
 */
export function EntryEditor({ initialContent, onSave }: Props) {
  // ...
}
```

### API Route Documentation
```typescript
/**
 * POST /api/ai/suggest
 * 
 * Generates AI-powered follow-up questions for journal entries
 * 
 * Request:
 * {
 *   text: string; // Journal entry content (will be PII-masked)
 * }
 * 
 * Response:
 * {
 *   suggestion: string; // AI-generated follow-up question
 * }
 * 
 * Errors:
 * - 400: Invalid input
 * - 500: AI service error
 */
```

---

## Specific Implementation Notes

### Real-Time Writing Companion
```typescript
// Implement with debounce to avoid excessive API calls
import { useDebounce } from '@/hooks/use-debounce';

export function AICompanion({ currentText }: Props) {
  const [suggestion, setSuggestion] = useState<string>('');
  const debouncedText = useDebounce(currentText, 2000);
  
  useEffect(() => {
    if (debouncedText.length > 100) {
      fetchSuggestion(debouncedText);
    }
  }, [debouncedText]);
  
  const fetchSuggestion = async (text: string) => {
    const response = await fetch('/api/ai/suggest', {
      method: 'POST',
      body: JSON.stringify({ text }),
    });
    const data = await response.json();
    setSuggestion(data.suggestion);
  };
  
  return suggestion ? (
    <aside className="ai-suggestion">{suggestion}</aside>
  ) : null;
}
```

### Sentiment Visualization
```typescript
import { LineChart, Line, XAxis, YAxis, Tooltip } from 'recharts';

export function SentimentChart({ entries }: Props) {
  const data = entries.map(entry => ({
    date: format(entry.createdAt, 'MMM dd'),
    sentiment: entry.sentimentScore,
  }));
  
  return (
    <LineChart width={600} height={300} data={data}>
      <XAxis dataKey="date" />
      <YAxis domain={[-1, 1]} />
      <Tooltip />
      <Line 
        type="monotone" 
        dataKey="sentiment" 
        stroke="#14b8a6" 
        strokeWidth={2}
      />
    </LineChart>
  );
}
```

---

## Common Pitfalls to Avoid

### ‚ùå DON'T
- Use 'use client' in API routes (they're always server-side)
- Send unmasked PII to Claude API
- Use default exports for components
- Fetch data in useEffect when Server Components work
- Ignore TypeScript errors
- Use any type
- Commit .env.local file
- Use localStorage for sensitive data without encryption
- Make synchronous API calls in components

### ‚úÖ DO
- Use Server Components by default
- Mask PII before external API calls
- Use named exports
- Fetch data in Server Components
- Fix TypeScript errors immediately
- Use proper types and interfaces
- Keep secrets in environment variables
- Implement proper session management
- Use async/await with proper error handling

---

## Accessibility (a11y)

- Use semantic HTML elements (`<nav>`, `<main>`, `<article>`)
- Implement proper ARIA labels
- Ensure keyboard navigation support
- Maintain sufficient color contrast
- Provide alt text for images
- Use focus indicators
- Support screen readers

---

## PWA Features

### Service Worker
```typescript
// next.config.js
const withPWA = require('next-pwa')({
  dest: 'public',
  disable: process.env.NODE_ENV === 'development',
});

module.exports = withPWA({
  // ... other config
});
```

### Manifest
```json
{
  "name": "MindfulSpace",
  "short_name": "MindfulSpace",
  "description": "AI-powered journaling companion",
  "start_url": "/",
  "display": "standalone",
  "background_color": "#ffffff",
  "theme_color": "#14b8a6",
  "icons": [...]
}
```

---

## Development Workflow

### Setup
1. Clone repository
2. Copy `.env.example` to `.env.local`
3. Fill in environment variables
4. Run `npm install`
5. Run `npx prisma db push`
6. Run `npm run dev`

### Before Committing
1. Run TypeScript check: `npm run type-check`
2. Run linter: `npm run lint`
3. Test critical features manually
4. Review changes for PII exposure
5. Ensure no console.logs remain

### Deployment Checklist
1. All environment variables set in Vercel
2. Database migrations applied
3. Production build succeeds
4. Critical user flows tested
5. Error monitoring configured

---

## Resources

**Official Docs:**
- Next.js: https://nextjs.org/docs
- Prisma: https://www.prisma.io/docs
- Anthropic Claude: https://docs.anthropic.com
- shadcn/ui: https://ui.shadcn.com
- Tailwind: https://tailwindcss.com/docs
- Supabase: https://supabase.com/docs

**Key Libraries:**
- sentiment: https://www.npmjs.com/package/sentiment
- compromise: https://www.npmjs.com/package/compromise
- recharts: https://recharts.org
- swr: https://swr.vercel.app

---

## CRITICAL REMINDERS FOR CURSOR AI

1. **Privacy First**: ALWAYS mask PII before sending to Claude API
2. **Claude API**: Use claude-sonnet-4-20250514 model (shows PANW product knowledge)
3. **TypeScript**: All code must be TypeScript with proper types
4. **Server Components**: Default to Server Components, use 'use client' sparingly
5. **Error Handling**: Implement try-catch and user-friendly error messages
6. **Named Exports**: Favor named exports over default exports
7. **Validation**: Use Zod for API request validation
8. **Testing**: Focus on critical paths (PII masking, AI integration, auth)
9. **Mobile-First**: Always consider mobile responsiveness
10. **Performance**: Debounce AI calls, cache responses, optimize queries

---

## Project-Specific Patterns

### Entry Creation Flow
1. User writes in editor
2. AFINN analyzes sentiment locally (instant feedback)
3. After 2-second typing pause, debounce triggers
4. Text is PII-masked
5. Sent to Claude API for suggestion
6. Suggestion displayed in sidebar
7. On save, entry stored with local analysis

### Weekly Summary Generation
1. Fetch entries from past 7 days
2. Aggregate: sentiment scores, theme frequencies
3. Send ONLY aggregated data to Claude (not full entries)
4. Claude generates narrative summary
5. Cache summary in database
6. Display with visualizations

### Privacy Architecture
- Local analysis (AFINN): 60% of processing
- Cloud AI (Claude): 40% with PII masking
- User controls: Toggle AI features, export data, delete account
- Transparency: Show when AI is processing, explain what data is sent

---

## Final Notes

This project is for a **Palo Alto Networks** hackathon with a **48-hour deadline**.

**Priorities:**
1. **Working features** > Perfect features
2. **Privacy demonstration** > Feature count
3. **Claude API usage** > Other AI services
4. **Code quality** > Clever tricks
5. **Clear demo** > Complex architecture

**Judge Focus:**
- Privacy-first approach (critical for PANW)
- Claude API integration (shows product knowledge)
- Real-time AI features (impressive demo)
- Professional code quality (TypeScript, error handling)
- Responsible AI (PII masking, user control)

**Remember:** Build incrementally, test frequently, commit often, and always prioritize privacy in your implementation decisions.

---

Good luck! Build something impressive! üöÄ
